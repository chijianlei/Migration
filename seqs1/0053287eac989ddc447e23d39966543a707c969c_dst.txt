evaluateEquation ( eq , 0 , true ) ; 
public List < Tuple < Equation , Double >> evaluateEquation ( Equation eq , int example , boolean nonTerminal )  
if ( size == 1 )  
return evaluateTrivialOne ( example , nonTerminal , eq )  
} else if ( size == 2 ) { 
temp . add ( getValueNonSplitableEquation ( splitEq , example , nonTerminal ) )  
return concatenateAll ( temp , example )  
private List < Tuple < Equation , Double >> concatenateAll ( List < List < Tuple < Equation , Double >>> temp , int e )  
if ( possibleSolution . y . equals ( examples . get ( e ) [ examples . get ( e ) . length - 1 ] ) )  
return concatenateAll ( temp , e )  
public List < Tuple < Equation , Double >> getValueNonSplitableEquation ( Equation eq , int e , boolean nonTerminal )  
if ( eq . getListOfSymbols ( ) . size ( ) == 1 )  
return evaluateTrivialOne ( e , nonTerminal , eq )  
} else if ( eq . getListOfSymbols ( ) . size ( ) == 2 )  
for ( ; start < symbols . size ( ) ; start += 2 )  
symbols . remove ( 0 ) ; 
Operand op = ( Operand ) symbols . get ( 0 )  
symbols . remove ( 0 ) ; 
List < Tuple < Equation , Double >> tuples = getValueNonSplitableEquation ( new Equation ( symbols ) , e , nonTerminal )  
for ( int i = 0 ; i < examples . get ( e ) . length - 1 ; i ++ )  
K = new Terminal ( "K" + i , examples . get ( e ) [ i ] )  
for ( Tuple < Equation , Double > t : tuples )  
List < Symbol > newSymbols = new ArrayList < Symbol > ( )  
newSymbols . add ( K )  
newSymbols . add ( op )  
newSymbols . addAll ( t . x . getListOfSymbols ( ) )  
Double value = Grammar . getValue ( ( ( Terminal ) K ) . getValue ( ) , op , t . y )  
result . add ( new Tuple < Equation , Double > ( new Equation ( newSymbols ) , value ) )  
for ( Tuple < Equation , Double > tuple : result )  
public List < Tuple < Equation , Double >> evaluateTrivalTwo ( Equation eq , int e , boolean nonTerminal )  
List < Tuple < Equation , Double >> result = new ArrayList < CopyOfObjectEvaluate . Tuple < Equation , Double >> ( )  
Double [ ] example = examples . get ( e )  
for ( int i = 0 ; i < example . length - 1 ; i ++ ) { 
List < Symbol > terminalEq = new ArrayList < Symbol > ( )  
terminalEq . add ( eq . getListOfSymbols ( ) . get ( 0 ) )  
terminalEq . add ( new Terminal ( "K" + i , example [ i ] ) )  
Equation possibleEq = new Equation ( terminalEq )  
double value = Grammar . evaluateTrivial ( possibleEq )  
result . add ( new Tuple < Equation , Double > ( possibleEq , value ) )  
public List < Tuple < Equation , Double >> evaluateTrivialOne ( int e , boolean nonTerminal , Equation equation )  
List < Tuple < Equation , Double >> result = new ArrayList < CopyOfObjectEvaluate . Tuple < Equation , Double >> ( )  
Double [ ] example = examples . get ( e )  
for ( int i = 0 ; i < example . length - 1 ; i ++ ) { 
List < Symbol > eqSymbols = new ArrayList < Symbol > ( )  
eqSymbols . add ( new Terminal ( "K" + i , example [ i ] ) )  
Equation eq = new Equation ( eqSymbols )  
result . add ( new Tuple < Equation , Double > ( eq , example [ i ] ) )  
Assert . assertEquals ( 2 , object . evaluateTrivalTwo ( new Equation ( symbols ) , 0 , true ) . size ( ) )  
symbols . add ( new NonTerminal ( "E" ) )  
symbols . add ( new Operand ( "*" , false , true , 1 ) )  
symbols . add ( new Operand ( "+" , true , true , 0 ) )  
symbols . add ( new Operand ( "-" , true , false , 0 ) )  
symbols . add ( new Operand ( "/" , false , false , 1 ) )  
for ( Tuple < Equation , Double > res : object . evaluateEquation ( eq , 0 , true ) )  
Assert . assertEquals ( 2 , object . evaluateTrivialOne ( 0 , true , null ) . size ( ) )  
