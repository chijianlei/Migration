evaluateEquation ( eq )  
public List < Tuple < Equation , Double >> evaluateEquation ( Equation eq )  
if ( size == 1 )  
return evaluateTrivialOne ( )  
} else if ( size == 2 ) { 
temp . add ( getValueNonSplitableEquation ( splitEq ) )  
return concatenateAll ( temp )  
private List < Tuple < Equation , Double >> concatenateAll ( List < List < Tuple < Equation , Double >>> temp )  
if ( possibleSolution . y . equals ( examples . get ( 0 ) [ examples . get ( 0 ) . length - 1 ] ) )  
return concatenateAll ( temp )  
public List < Tuple < Equation , Double >> getValueNonSplitableEquation ( Equation eq )  
if ( eq . getListOfSymbols ( ) . size ( ) == 1 )  
return evaluateTrivialOne ( )  
} else if ( eq . getListOfSymbols ( ) . size ( ) == 2 )  
for ( ; start < symbols . size ( ) ; start += 2 )  
symbols . remove ( 0 ) ; 
Operand op = ( Operand ) symbols . get ( 0 )  
symbols . remove ( 0 ) ; 
List < Tuple < Equation , Double >> tuples = getValueNonSplitableEquation ( new Equation ( symbols ) )  
for ( int i = 0 ; i < examples . get ( 0 ) . length - 1 ; i ++ )  
Symbol K = new Terminal ( "K" + i , examples . get ( 0 ) [ i ] )  
for ( Tuple < Equation , Double > t : tuples )  
List < Symbol > newSymbols = new ArrayList < Symbol > ( )  
newSymbols . add ( K )  
newSymbols . add ( op )  
newSymbols . addAll ( t . x . getListOfSymbols ( ) )  
Double value = Grammar . getValue ( ( ( Terminal ) K ) . getValue ( ) , op , t . y )  
result . add ( new Tuple < Equation , Double > ( new Equation ( newSymbols ) , value ) )  
for ( Tuple < Equation , Double > tuple : result )  
public List < Tuple < Equation , Double >> evaluateTrivalTwo ( Equation eq )  
List < Tuple < Equation , Double >> result = new ArrayList < CopyOfObjectEvaluate . Tuple < Equation , Double >> ( )  
Double [ ] example = examples . get ( 0 )  
for ( int i = 0 ; i < example . length - 1 ; i ++ ) { 
List < Symbol > terminalEq = new ArrayList < Symbol > ( )  
terminalEq . add ( eq . getListOfSymbols ( ) . get ( 0 ) )  
terminalEq . add ( new Terminal ( "K" + i , example [ i ] ) )  
Equation possibleEq = new Equation ( terminalEq )  
double value = Grammar . evaluateTrivial ( possibleEq )  
result . add ( new Tuple < Equation , Double > ( possibleEq , value ) )  
public List < Tuple < Equation , Double >> evaluateTrivialOne ( )  
List < Tuple < Equation , Double >> result = new ArrayList < CopyOfObjectEvaluate . Tuple < Equation , Double >> ( )  
double goal = example [ example . length - 1 ]  
for ( int i = 0 ; i < example . length - 1 ; i ++ ) { 
List < Symbol > eqSymbols = new ArrayList < Symbol > ( )  
eqSymbols . add ( new Terminal ( "K" + i , example [ i ] ) )  
Equation eq = new Equation ( eqSymbols )  
result . add ( new Tuple < Equation , Double > ( eq , example [ i ] ) )  
Assert . assertEquals ( 2 , object . evaluateTrivalTwo ( new Equation ( symbols ) ) . size ( ) )  
symbols . add ( new NonTerminal ( "E" ) )  
symbols . add ( new Operand ( "*" , false , true , 1 ) )  
symbols . add ( new Operand ( "+" , true , true , 0 ) )  
symbols . add ( new Operand ( "-" , true , false , 0 ) )  
symbols . add ( new Operand ( "/" , false , false , 1 ) )  
for ( Tuple < Equation , Double > res : object . evaluateEquation ( eq ) )  
Assert . assertEquals ( 2 , object . evaluateTrivialOne ( ) . size ( ) )  
