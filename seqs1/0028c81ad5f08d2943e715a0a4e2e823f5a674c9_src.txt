public Observable < Supplier < OrderCallResult >> orderCallObservable ( final Supplier < OrderCallResult > socr , final OrderEventType doneType , final OrderEventType rejectType )  
final OrderCallResult orderCallResult = socr . get ( )  
final Observable < OrderEvent > orderEventObservable = orderEventObservable ( orderCallResult . orderOpt ( ) . get ( ) , doneType , rejectType )  
public Observable < OrderEvent > orderEventObservable ( final IOrder order , final OrderEventType doneType , final OrderEventType rejectType )  
return orderEventObservable . filter ( oe -> oe . order ( ) . equals ( order ) ) . takeUntil ( oe -> rejectType == oe . type ( ) || doneType == oe . type ( ) ) . flatMap ( orderEvent -> Observable . create ( subscriber -> { updateRepository ( orderEvent ) ; if ( rejectType == orderEvent . type ( ) ) { logger . warn ( "Received reject event type: " + orderEvent . type ( ) ) ; subscriber . onError ( new TaskException ( "" ) )  
if ( doneType == orderEvent . type ( ) )  
logger . info ( "Received done event type: " + doneType )  
subscriber . onNext ( orderEvent )  
if ( isSLSetTo ( newSL ) . test ( orderToChangeSL ) ) 
return Observable . empty ( )  
return taskObservableWithRetry ( ( ) -> orderUtil . changeSL ( orderToChangeSL , newSL ) , OrderEventType . SL_CHANGE_OK , OrderEventType . CHANGE_SL_REJECTED ) . doOnSubscribe ( ( ) -> logger . info ( "Start change SL from " + orderToChangeSL . getStopLossPrice ( ) + " to new SL: " + newSL ) )  
if ( isTPSetTo ( newTP ) . test ( orderToChangeTP ) ) 
return Observable . empty ( )  
return taskObservableWithRetry ( ( ) -> orderUtil . changeTP ( orderToChangeTP , newTP ) , OrderEventType . TP_CHANGE_OK , OrderEventType . CHANGE_TP_REJECTED ) . doOnSubscribe ( ( ) -> logger . info ( "Start change TP from " + orderToChangeTP . getTakeProfitPrice ( ) + " to new TP: " + newTP ) )  
return taskObservableWithRetry ( ( ) -> orderUtil . merge ( mergeLabel , orderRepository . filled ( ) ) , OrderEventType . MERGE_OK , OrderEventType . MERGE_REJECTED ) . doOnSubscribe ( ( ) -> logger . info ( "Starting merge with label: " + mergeLabel ) )  
if ( isClosed . test ( orderToClose ) ) 
return Observable . empty ( )  
return taskObservableWithRetry ( ( ) -> orderUtil . close ( orderToClose ) , OrderEventType . CLOSE_OK , OrderEventType . CLOSE_REJECTED ) . doOnSubscribe ( ( ) -> logger . info ( "Starting close for label: " + orderToClose . getLabel ( ) ) )  
return orderCallObservable ( ( ) -> orderUtil . submit ( orderParams ) , OrderEventType . FULL_FILL_OK , OrderEventType . FILL_REJECTED ) . doOnSubscribe ( ( ) -> logger . info ( "Starting submit with label: " + orderParams . label ( ) ) )  
private Observable < Supplier < OrderCallResult >> taskObservableWithRetry ( final Supplier < OrderCallResult > ocrs , final OrderEventType doneType , final OrderEventType rejectType )  
return orderCallObservable . retry ( ( a , e ) -> e instanceof TaskException && a < PlatformSettings . MAX_NUM_RETRIES_ON_FAIL )  
return Observable . merge ( filledOrdersStream ( ) . map ( order -> changeSLTask ( order , newSL ) ) . collect ( Collectors . toList ( ) ) )  
return Observable . merge ( filledOrdersStream ( ) . map ( order -> changeTPTask ( order , newTP ) ) . collect ( Collectors . toList ( ) ) )  
return Observable . merge ( submittedOrders ( ) . stream ( ) . map ( order -> closeTask ( order ) ) . collect ( Collectors . toList ( ) ) ) . doOnSubscribe ( ( ) -> logger . info ( "Start to close all position orders..." ) )  
return Observable . concat ( multiChangeTPTask ( NO_STOP_LOSS_PRICE ) . doOnSubscribe ( ( ) -> logger . info ( "Start to remove all TPs..." ) ) , multiChangeSLTask ( NO_STOP_LOSS_PRICE ) . doOnSubscribe ( ( ) -> logger . info ( "Start to remove all SLs..." ) ) , mergeTask ( mergeLabel ) , multiChangeSLTask ( restoreSL ) . doOnSubscribe ( ( ) -> logger . info ( "Start restore SL..." ) ) , multiChangeTPTask ( restoreTP ) . doOnSubscribe ( ( ) -> logger . info ( "Start restore TP..." ) ) )  
private Stream < IOrder > filledOrdersStream ( )  
return orderRepository . filled ( ) . stream ( )  
