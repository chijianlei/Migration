public static BlockPos getAreaSizeFromRelativeEndPosition ( BlockPos posEnd ) 
int x = posEnd . getX ( )  
int y = posEnd . getY ( )  
int z = posEnd . getZ ( )  
IBlockState state = blockInfo . blockState  
if ( this . replaceMode == ReplaceMode . EVERYTHING || ( this . replaceMode == ReplaceMode . WITH_NON_AIR && state . getMaterial ( ) != Material . AIR ) || world . isAirBlock ( pos ) ) 
state = state . withMirror ( this . placement . getMirror ( ) ) . withRotation ( this . placement . getRotation ( ) )  
success = world . setBlockState ( pos , state , 2 )  
success = world . setBlockState ( pos , state , 2 )  
int x1 = posStart . getX ( )  
int y1 = posStart . getY ( )  
int z1 = posStart . getZ ( )  
List < Entity > existingEntities = world . getEntitiesWithinAABBExcludingEntity ( null , bb )  
public void takeBlocksFromWorld ( World worldIn , BlockPos startPos , BlockPos endPosRelative , boolean takeEntities ) 
BlockPos endPos = startPos . add ( endPosRelative )  
this . size = PositionUtils . getAreaSizeFromRelativeEndPosition ( endPosRelative )  
for ( BlockPos . MutableBlockPos posMutable : BlockPos . getAllInBoxMutable ( startPos , endPos ) ) 
BlockPos posRelative = posMutable . subtract ( startPos )  
public void takeEntitiesFromWorld ( World world , BlockPos startPos , BlockPos endPos ) 
List < Entity > list = world . < Entity > getEntitiesWithinAABB ( Entity . class , new AxisAlignedBB ( startPos , endPos ) , new Predicate < Entity > ( ) { public boolean apply ( Entity entity ) { return ( entity instanceof EntityPlayer ) == false ; } } )  
for ( Entity entity : list ) 
Vec3d vec3d = new Vec3d ( entity . posX - startPos . getX ( ) , entity . posY - startPos . getY ( ) , entity . posZ - startPos . getZ ( ) )  
pos = ( ( EntityPainting ) entity ) . getHangingPosition ( ) . subtract ( startPos )  
