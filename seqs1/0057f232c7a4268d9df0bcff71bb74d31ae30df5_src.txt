if ( execute ( ) )  
public CCDSolver ( ArrayList < ? extends Frame > chain , Frame target )  
public boolean execute ( )  
return true  
for ( int i = chain . size ( ) - 2 ; i >= 0 ; i -- )  
delta = new Rot ( l1 , l2 )  
delta = new Quat ( l1 , l2 )  
public static abstract class FABRIKSolver extends Solver  
protected ArrayList < Vec > positions = new ArrayList < Vec > ( )  
public ArrayList < Vec > getPositions ( ) { return positions ;  
public void executeForwardReaching ( ArrayList < ? extends Frame > chain )  
for ( int i = chain . size ( ) - 2 ; i >= 0 ; i -- )  
Vec pos_i = positions . get ( i )  
Vec pos_i1 = positions . get ( i + 1 )  
if ( i != chain . size ( ) - 2 )  
pos_i2 = positions . get ( i + 2 )  
Vec pos_i1_constrained = applyConstraintsForwardStage ( chain . get ( i + 1 ) , chain . get ( i + 1 ) . referenceFrame ( ) , pos_i , pos_i1 , pos_i2 )  
Vec diff = Vec . subtract ( pos_i1 , pos_i1_constrained )  
pos_i . add ( diff )  
float r_i = Vec . distance ( pos_i , pos_i1 )  
if ( dist_i == 0 )  
positions . set ( i , pos_i1 . get ( ) )  
float lambda_i = dist_i / r_i  
Vec new_pos = Vec . multiply ( pos_i1 , 1.f - lambda_i )  
new_pos . add ( Vec . multiply ( pos_i , lambda_i ) )  
positions . set ( i , new_pos )  
public float executeBackwardReaching ( ArrayList < ? extends Frame > chain )  
float change = 0  
for ( int i = 0 ; i < chain . size ( ) - 1 ; i ++ )  
positions . set ( i + 1 , pos_i1 )  
positions . set ( i + 1 , pos_i . get ( ) )  
positions . set ( i + 1 , new_pos )  
Vec constrained_pos = chain . get ( i + 1 ) . position ( ) . get ( )  
change += Vec . distance ( positions . get ( i + 1 ) , constrained_pos )  
positions . set ( i + 1 , constrained_pos )  
Vec diff = Vec . subtract ( p , o )  
if ( parent . constraint ( ) instanceof BallAndSocket )  
if ( q == null ) return p  
Vec newTranslation = Vec . subtract ( q , p )  
Quat deltaRestRotation = new Quat ( j . translation ( ) , newTranslation )  
Vec target = Quat . multiply ( desired , j . translation ( ) )  
Quat restRotation = ( Quat ) Quat . compose ( parent . rotation ( ) , constraint . getRestRotation ( ) . inverse ( ) )  
restRotation = ( Quat ) Quat . compose ( constraint . getRestRotation ( ) , restRotation )  
target . multiply ( Vec . subtract ( p , o ) . magnitude ( ) )  
if ( parent . constraint ( ) instanceof Hinge )  
if ( parent . is2D ( ) )  
Hinge constraint = ( Hinge ) parent . constraint ( )  
Rot constrained = ( Rot ) constraint . constrainRotation ( desired , parent )  
Vec target = constrained . rotate ( j . translation ( ) )  
target . multiply ( Vec . subtract ( p , o ) . magnitude ( ) )  
BallAndSocket constraint = ( BallAndSocket ) parent . constraint ( )  
public float change ( ArrayList < ? extends Frame > chain )  
float change = 0.f  
for ( int i = 0 ; i < chain . size ( ) ; i ++ )  
change += Vec . distance ( chain . get ( i ) . position ( ) , positions . get ( i ) )  
public ChainSolver ( ArrayList < ? extends Frame > chain , Frame target )  
setChain ( chain )  
positions = new ArrayList < Vec > ( )  
for ( Frame joint : chain )  
positions . add ( joint . position ( ) . get ( ) )  
this . target = target  
this . prevTarget = 
target == null ? null : new Frame ( target . position ( ) . get ( ) , target . orientation ( ) . get ( ) )  
== null ? null : new Frame ( target . position ( ) . get ( ) , target . orientation ( ) . get ( ) )  
: new Frame ( target . position ( ) . get ( ) , target . orientation ( ) . get ( ) )  
public boolean execute ( )  
for ( int i = 0 ; i < chain . size ( ) ; i ++ )  
public TreeSolver ( GenericFrame genericFrame )  
@ Override public boolean execute ( )  
