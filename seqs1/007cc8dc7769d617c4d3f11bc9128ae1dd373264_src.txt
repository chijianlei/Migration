private Optional < Integer > parseIndex ( String command )  
final Matcher matcher = PERSON_INDEX_ARGS_FORMAT . matcher ( command . trim ( ) )  
if ( ! matcher . matches ( ) )  
return Optional . empty ( )  
String index = matcher . group ( "targetIndex" )  
if ( ! StringUtil . isUnsignedInteger ( index ) )  
return Optional . empty ( )  
return Optional . of ( Integer . parseInt ( index ) )  
private Optional < List < Integer >> parseIndices ( String command )  
final String [ ] tokenized = command . trim ( ) . split ( "\\s+" )  
final Map < Boolean , List < String >> isTokenWithRange = Stream . of ( tokenized ) . collect ( Collectors . partitioningBy ( token -> token . contains ( PERSON_INDEX_RANGE_INDICATOR ) ) )  
final Optional < List < Integer >> indicesFromRangedTokens = parseRangedIndexTokens ( isTokenWithRange . get ( true ) )  
final Optional < List < Integer >> indicesFromNonRangedTokens = parseNonRangedIndexTokens ( isTokenWithRange . get ( false ) )  
private Optional < List < Integer >> parseRangedIndexTokens ( List < String > tokens )  
final List < Integer > indices = new ArrayList < > ( )  
final Matcher matcher = PERSON_INDEX_RANGE_ARGS_FORMAT . matcher ( token )  
if ( ! matcher . matches ( ) )  
return Optional . empty ( )  
final Optional < Integer > startIdx = parseIndex ( matcher . group ( "rangeStart" ) )  
final Optional < Integer > endIdx = parseIndex ( matcher . group ( "rangeEnd" ) )  
if ( ! startIdx . isPresent ( ) || ! endIdx . isPresent ( ) )  
return Optional . empty ( )  
final int actualStartIndex = Math . min ( startIdx . get ( ) , endIdx . get ( ) )  
final int actualEndIndex = Math . max ( startIdx . get ( ) , endIdx . get ( ) )  
return Optional . of ( indices )  
private Optional < List < Integer >> parseNonRangedIndexTokens ( List < String > tokens )  
