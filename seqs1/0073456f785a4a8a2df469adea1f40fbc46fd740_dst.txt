@ Override public Collection < RepairRun > getRepairRunsWithState ( RunState runState )  
return repairRuns . stream ( ) . filter ( repairRun -> repairRun . getRunState ( ) == runState ) . collect ( Collectors . toSet ( ) )  
@ Override public Optional < RepairRun > deleteRepairRun ( UUID id )  
Optional < RepairRun > repairRun = getRepairRun ( id )  
if ( repairRun . isPresent ( ) )  
session . executeAsync ( deleteRepairRunByUnitPrepStmt . bind ( id , repairRun . get ( ) . getRepairUnitId ( ) ) )  
session . executeAsync ( deleteRepairRunByClusterPrepStmt . bind ( id , repairRun . get ( ) . getClusterName ( ) ) )  
session . executeAsync ( deleteRepairRunPrepStmt . bind ( id ) )  
@ Override public RepairUnit addRepairUnit ( RepairUnit . Builder newRepairUnit )  
RepairUnit repairUnit = newRepairUnit . build ( UUIDs . timeBased ( ) )  
session . execute ( insertRepairUnitPrepStmt . bind ( repairUnit . getId ( ) , repairUnit . getClusterName ( ) , repairUnit . getKeyspaceName ( ) , repairUnit . getColumnFamilies ( ) , repairUnit . getIncrementalRepair ( ) , repairUnit . getNodes ( ) , repairUnit . getDatacenters ( ) ) )  
@ Override public Optional < RepairUnit > getRepairUnit ( UUID id )  
RepairUnit repairUnit = null  
Row repairUnitRow = session . execute ( getRepairUnitPrepStmt . bind ( id ) ) . one ( )  
if ( repairUnitRow != null )  
repairUnit = new RepairUnit . Builder ( repairUnitRow . getString ( "cluster_name" ) , repairUnitRow . getString ( "keyspace_name" ) , repairUnitRow . getSet ( "column_families" , String . class ) , repairUnitRow . getBool ( "incremental_repair" ) , repairUnitRow . getSet ( "nodes" , String . class ) , repairUnitRow . getSet ( "datacenters" , String . class ) ) . build ( id )  
return Optional . fromNullable ( repairUnit )  
@ Override public Optional < RepairUnit > getRepairUnit ( String cluster , String keyspace , Set < String > columnFamilyNames )  
RepairUnit repairUnit = null  
Statement stmt = new SimpleStatement ( SELECT_REPAIR_UNIT )  
stmt . setIdempotent ( Boolean . TRUE )  
ResultSet results = session . execute ( stmt )  
for ( Row repairUnitRow : results )  
if ( repairUnitRow . getString ( "cluster_name" ) . equals ( cluster ) && repairUnitRow . getString ( "keyspace_name" ) . equals ( keyspace ) && repairUnitRow . getSet ( "column_families" , String . class ) . equals ( columnFamilyNames ) )  
repairUnit = new RepairUnit . Builder ( repairUnitRow . getString ( "cluster_name" ) , repairUnitRow . getString ( "keyspace_name" ) , repairUnitRow . getSet ( "column_families" , String . class ) , repairUnitRow . getBool ( "incremental_repair" ) , repairUnitRow . getSet ( "nodes" , String . class ) , repairUnitRow . getSet ( "datacenters" , String . class ) ) . build ( repairUnitRow . getUUID ( "id" ) )  
return Optional . fromNullable ( repairUnit )  
@ Override public boolean updateRepairSegment ( RepairSegment segment )  
Date startTime = null  
if ( segment . getStartTime ( ) != null )  
startTime = segment . getStartTime ( ) . toDate ( )  
session . execute ( insertRepairSegmentPrepStmt . bind ( segment . getRunId ( ) , segment . getId ( ) , segment . getRepairUnitId ( ) , segment . getStartToken ( ) , segment . getEndToken ( ) , segment . getState ( ) . ordinal ( ) , segment . getCoordinatorHost ( ) , startTime , segment . getEndTime ( ) . toDate ( ) , segment . getFailCount ( ) ) )  
return true  
@ Override public Optional < RepairSegment > getRepairSegment ( UUID runId , UUID segmentId )  
RepairSegment segment = null  
Row segmentRow = session . execute ( getRepairSegmentPrepStmt . bind ( runId , segmentId ) ) . one ( )  
if ( segmentRow != null )  
segment = createRepairSegmentFromRow ( segmentRow )  
return Optional . fromNullable ( segment )  
@ Override public Collection < RepairSegment > getRepairSegmentsForRun ( UUID runId )  
Collection < RepairSegment > segments = Lists . newArrayList ( )  
ResultSet segmentsIdResultSet = session . execute ( getRepairSegmentsByRunIdPrepStmt . bind ( runId ) )  
for ( Row segmentRow : segmentsIdResultSet )  
segments . add ( createRepairSegmentFromRow ( segmentRow ) )  
@ Override public Collection < RepairSegment > getRepairSegmentsForRunInLocalMode ( UUID runId , List < RingRange > localRanges )  
LOG . debug ( "Getting ranges for local node {}" , localRanges )  
Collection < RepairSegment > segments = Lists . newArrayList ( )  
ResultSet segmentsResultSet = session . execute ( getRepairSegmentsByRunIdPrepStmt . bind ( runId ) )  
segmentsResultSet . forEach ( segmentRow -> { RepairSegment seg = createRepairSegmentFromRow ( segmentRow ) ; RingRange range = new RingRange ( seg . getStartToken ( ) , seg . getEndToken ( ) ) ; localRanges . stream ( ) . forEach ( localRange -> { if ( localRange . encloses ( range ) ) { segments . add ( seg ) ; } } ) ; } )  
RepairSegment seg = createRepairSegmentFromRow ( segmentRow )  
RingRange range = new RingRange ( seg . getStartToken ( ) , seg . getEndToken ( ) )  
localRanges . stream ( ) . forEach ( localRange -> { if ( localRange . encloses ( range ) ) { segments . add ( seg ) ; } } )  
if ( localRange . encloses ( range ) )  
segments . add ( seg )  
private static boolean segmentIsWithinRange ( RepairSegment segment , RingRange range )  
return range . encloses ( new RingRange ( segment . getStartToken ( ) , segment . getEndToken ( ) ) )  
private static RepairSegment createRepairSegmentFromRow ( Row segmentRow )  
return new RepairSegment . Builder ( new RingRange ( new BigInteger ( segmentRow . getVarint ( "start_token" ) + "" ) , new BigInteger ( segmentRow . getVarint ( "end_token" ) + "" ) ) , segmentRow . getUUID ( "repair_unit_id" ) ) . withRunId ( segmentRow . getUUID ( "id" ) ) . coordinatorHost ( segmentRow . getString ( "coordinator_host" ) ) . endTime ( new DateTime ( segmentRow . getTimestamp ( "segment_end_time" ) ) ) . failCount ( segmentRow . getInt ( "fail_count" ) ) . startTime ( new DateTime ( segmentRow . getTimestamp ( "segment_start_time" ) ) ) . state ( State . values ( ) [ segmentRow . getInt ( "segment_state" ) ] ) . build ( segmentRow . getUUID ( "segment_id" ) )  
@ Override public Optional < RepairSegment > getNextFreeSegmentInRange ( UUID runId , Optional < RingRange > range )  
List < RepairSegment > segments = Lists . < RepairSegment > newArrayList ( getRepairSegmentsForRun ( runId ) )  
Collections . shuffle ( segments )  
for ( RepairSegment seg : segments )  
if ( seg . getState ( ) . equals ( State . NOT_STARTED ) && withinRange ( seg , range ) )  
return Optional . of ( seg )  
return Optional . absent ( )  
@ Override public Collection < RepairSegment > getSegmentsWithState ( UUID runId , State segmentState )  
Collection < RepairSegment > foundSegments = Lists . < RepairSegment > newArrayList ( )  
List < RepairSegment > segments = Lists . < RepairSegment > newArrayList ( )  
segments . addAll ( getRepairSegmentsForRun ( runId ) )  
for ( RepairSegment seg : segments )  
if ( seg . getState ( ) . equals ( segmentState ) )  
foundSegments . add ( seg )  
@ Override public Collection < RepairParameters > getOngoingRepairsInCluster ( String clusterName )  
Collection < RepairParameters > repairs = Lists . < RepairParameters > newArrayList ( )  
Collection < RepairRun > repairRuns = getRepairRunsForCluster ( clusterName )  
for ( RepairRun repairRun : repairRuns )  
Collection < RepairSegment > runningSegments = getSegmentsWithState ( repairRun . getId ( ) , State . RUNNING )  
for ( RepairSegment segment : runningSegments )  
Optional < RepairUnit > repairUnit = getRepairUnit ( repairRun . getRepairUnitId ( ) )  
repairs . add ( new RepairParameters ( new RingRange ( segment . getStartToken ( ) , segment . getEndToken ( ) ) , repairUnit . get ( ) . getKeyspaceName ( ) , repairUnit . get ( ) . getColumnFamilies ( ) , repairRun . getRepairParallelism ( ) ) )  
LOG . debug ( "found ongoing repairs {} {}" , repairs . size ( ) , repairs )  
@ Override public Collection < UUID > getRepairRunIdsForCluster ( String clusterName )  
Collection < UUID > repairRunIds = Lists . < UUID > newArrayList ( )  
ResultSet results = session . execute ( getRepairRunForClusterPrepStmt . bind ( clusterName ) )  
for ( Row result : results )  
repairRunIds . add ( result . getUUID ( "id" ) )  
@ Override public int getSegmentAmountForRepairRun ( UUID runId )  
return getRepairSegmentsForRun ( runId ) . size ( )  
@ Override public int getSegmentAmountForRepairRunWithState ( UUID runId , State state )  
return getSegmentsWithState ( runId , state ) . size ( )  
@ Override public RepairSchedule addRepairSchedule ( com . spotify . reaper . core . RepairSchedule . Builder repairSchedule )  
RepairSchedule schedule = repairSchedule . build ( UUIDs . timeBased ( ) )  
updateRepairSchedule ( schedule )  
@ Override public Optional < RepairSchedule > getRepairSchedule ( UUID repairScheduleId )  
Row sched = session . execute ( getRepairSchedulePrepStmt . bind ( repairScheduleId ) ) . one ( )  
sched != null 
Optional . fromNullable ( createRepairScheduleFromRow ( sched ) ) : Optional . absent ( )  
: Optional . absent ( )  
private RepairSchedule createRepairScheduleFromRow ( Row repairScheduleRow )  
return new RepairSchedule . Builder ( repairScheduleRow . getUUID ( "repair_unit_id" ) , RepairSchedule . State . valueOf ( repairScheduleRow . getString ( "state" ) ) , repairScheduleRow . getInt ( "days_between" ) , new DateTime ( repairScheduleRow . getTimestamp ( "next_activation" ) ) , ImmutableList . copyOf ( repairScheduleRow . getSet ( "run_history" , UUID . class ) ) , repairScheduleRow . getInt ( "segment_count" ) , RepairParallelism . fromName ( repairScheduleRow . getString ( "repair_parallelism" ) ) , repairScheduleRow . getDouble ( "intensity" ) , new DateTime ( repairScheduleRow . getTimestamp ( "creation_time" ) ) ) . owner ( repairScheduleRow . getString ( "owner" ) ) . pauseTime ( new DateTime ( repairScheduleRow . getTimestamp ( "pause_time" ) ) ) . build ( repairScheduleRow . getUUID ( "id" ) )  
@ Override public Collection < RepairSchedule > getRepairSchedulesForCluster ( String clusterName )  
Collection < RepairSchedule > schedules = Lists . < RepairSchedule > newArrayList ( )  
ResultSet scheduleIds = session . execute ( getRepairScheduleByClusterAndKsPrepStmt . bind ( clusterName , " " ) )  
for ( Row scheduleId : scheduleIds )  
Optional < RepairSchedule > schedule = getRepairSchedule ( scheduleId . getUUID ( "repair_schedule_id" ) )  
if ( schedule . isPresent ( ) )  
schedules . add ( schedule . get ( ) )  
@ Override public Collection < RepairSchedule > getRepairSchedulesForKeyspace ( String keyspaceName )  
Collection < RepairSchedule > schedules = Lists . < RepairSchedule > newArrayList ( )  
ResultSet scheduleIds = session . execute ( getRepairScheduleByClusterAndKsPrepStmt . bind ( " " , keyspaceName ) )  
for ( Row scheduleId : scheduleIds )  
Optional < RepairSchedule > schedule = getRepairSchedule ( scheduleId . getUUID ( "repair_schedule_id" ) )  
if ( schedule . isPresent ( ) )  
schedules . add ( schedule . get ( ) )  
@ Override public Collection < RepairSchedule > getRepairSchedulesForClusterAndKeyspace ( String clusterName , String keyspaceName )  
Collection < RepairSchedule > schedules = Lists . < RepairSchedule > newArrayList ( )  
ResultSet scheduleIds = session . execute ( getRepairScheduleByClusterAndKsPrepStmt . bind ( clusterName , keyspaceName ) )  
for ( Row scheduleId : scheduleIds )  
Optional < RepairSchedule > schedule = getRepairSchedule ( scheduleId . getUUID ( "repair_schedule_id" ) )  
if ( schedule . isPresent ( ) )  
schedules . add ( schedule . get ( ) )  
@ Override public Collection < RepairSchedule > getAllRepairSchedules ( )  
Collection < RepairSchedule > schedules = Lists . < RepairSchedule > newArrayList ( )  
Statement stmt = new SimpleStatement ( SELECT_REPAIR_SCHEDULE )  
stmt . setIdempotent ( Boolean . TRUE )  
ResultSet scheduleResults = session . execute ( stmt )  
for ( Row scheduleRow : scheduleResults )  
schedules . add ( createRepairScheduleFromRow ( scheduleRow ) )  
@ Override public boolean updateRepairSchedule ( RepairSchedule newRepairSchedule )  
final Set < UUID > repairHistory = Sets . newHashSet ( )  
repairHistory . addAll ( newRepairSchedule . getRunHistory ( ) )  
RepairUnit repairUnit = getRepairUnit ( newRepairSchedule . getRepairUnitId ( ) ) . get ( )  
List < ResultSetFuture > futures = Lists . newArrayList ( )  
futures . add ( session . executeAsync ( insertRepairSchedulePrepStmt . bind ( newRepairSchedule . getId ( ) , newRepairSchedule . getRepairUnitId ( ) , newRepairSchedule . getState ( ) . toString ( ) , newRepairSchedule . getDaysBetween ( ) , newRepairSchedule . getNextActivation ( ) , repairHistory , newRepairSchedule . getSegmentCount ( ) , newRepairSchedule . getRepairParallelism ( ) . toString ( ) , newRepairSchedule . getIntensity ( ) , newRepairSchedule . getCreationTime ( ) , newRepairSchedule . getOwner ( ) , newRepairSchedule . getPauseTime ( ) ) ) )  
futures . add ( session . executeAsync ( insertRepairScheduleByClusterAndKsPrepStmt . bind ( repairUnit . getClusterName ( ) , repairUnit . getKeyspaceName ( ) , newRepairSchedule . getId ( ) ) ) )  
futures . add ( session . executeAsync ( insertRepairScheduleByClusterAndKsPrepStmt . bind ( repairUnit . getClusterName ( ) , " " , newRepairSchedule . getId ( ) ) ) )  
futures . add ( session . executeAsync ( insertRepairScheduleByClusterAndKsPrepStmt . bind ( " " , repairUnit . getKeyspaceName ( ) , newRepairSchedule . getId ( ) ) ) )  
Futures . allAsList ( futures ) . get ( )  
catch ( InterruptedException | ExecutionException ex )  
LOG . error ( "failed to quorum update repair schedule " + newRepairSchedule . getId ( ) , ex )  
return true  
@ Override public Optional < RepairSchedule > deleteRepairSchedule ( UUID id )  
Optional < RepairSchedule > repairSchedule = getRepairSchedule ( id )  
if ( repairSchedule . isPresent ( ) )  
RepairUnit repairUnit = getRepairUnit ( repairSchedule . get ( ) . getRepairUnitId ( ) ) . get ( )  
session . executeAsync ( deleteRepairScheduleByClusterAndKsPrepStmt . bind ( repairUnit . getClusterName ( ) , repairUnit . getKeyspaceName ( ) , repairSchedule . get ( ) . getId ( ) ) )  
session . executeAsync ( deleteRepairScheduleByClusterAndKsPrepStmt . bind ( repairUnit . getClusterName ( ) , " " , repairSchedule . get ( ) . getId ( ) ) )  
session . executeAsync ( deleteRepairScheduleByClusterAndKsPrepStmt . bind ( " " , repairUnit . getKeyspaceName ( ) , repairSchedule . get ( ) . getId ( ) ) )  
session . executeAsync ( deleteRepairSchedulePrepStmt . bind ( repairSchedule . get ( ) . getId ( ) ) )  
@ Override public Collection < RepairRunStatus > getClusterRunStatuses ( String clusterName , int limit )  
Collection < RepairRunStatus > repairRunStatuses = Lists . < RepairRunStatus > newArrayList ( )  
Collection < RepairRun > repairRuns = getRepairRunsForCluster ( clusterName )  
for ( RepairRun repairRun : repairRuns )  
Collection < RepairSegment > segments = getRepairSegmentsForRun ( repairRun . getId ( ) )  
Optional < RepairUnit > repairUnit = getRepairUnit ( repairRun . getRepairUnitId ( ) )  
int segmentsRepaired = ( int ) segments . stream ( ) . filter ( seg -> seg . getState ( ) . equals ( RepairSegment . State . DONE ) ) . count ( )  
repairRunStatuses . add ( new RepairRunStatus ( repairRun , repairUnit . get ( ) , segmentsRepaired ) )  
@ Override public Collection < RepairScheduleStatus > getClusterScheduleStatuses ( String clusterName )  
Collection < RepairSchedule > repairSchedules = getRepairSchedulesForCluster ( clusterName )  
Collection < RepairScheduleStatus > repairScheduleStatuses = repairSchedules . stream ( ) . map ( sched -> new RepairScheduleStatus ( sched , getRepairUnit ( sched . getRepairUnitId ( ) ) . get ( ) ) ) . collect ( Collectors . toList ( ) )  
private RepairRun buildRepairRunFromRow ( Row repairRunResult , UUID id )  
return new RepairRun . Builder ( repairRunResult . getString ( "cluster_name" ) , repairRunResult . getUUID ( "repair_unit_id" ) , new DateTime ( repairRunResult . getTimestamp ( "creation_time" ) ) , repairRunResult . getDouble ( "intensity" ) , repairRunResult . getInt ( "segment_count" ) , RepairParallelism . fromName ( repairRunResult . getString ( "repair_parallelism" ) ) ) . cause ( repairRunResult . getString ( "cause" ) ) . owner ( repairRunResult . getString ( "owner" ) ) . endTime ( new DateTime ( repairRunResult . getTimestamp ( "end_time" ) ) ) . lastEvent ( repairRunResult . getString ( "last_event" ) ) . pauseTime ( new DateTime ( repairRunResult . getTimestamp ( "pause_time" ) ) ) . runState ( RunState . valueOf ( repairRunResult . getString ( "state" ) ) ) . startTime ( new DateTime ( repairRunResult . getTimestamp ( "start_time" ) ) ) . build ( id )  
@ Override public boolean takeLead ( UUID leaderId )  
LOG . debug ( "Trying to take lead on segment {}" , leaderId )  
ResultSet lwtResult = session . execute ( takeLeadPrepStmt . bind ( leaderId , AppContext . REAPER_INSTANCE_ID , AppContext . REAPER_INSTANCE_ADDRESS ) )  
if ( lwtResult . wasApplied ( ) )  
LOG . debug ( "Took lead on segment {}" , leaderId )  
return true  
LOG . debug ( "Could not take lead on segment {}" , leaderId )  
return false  
@ Override public boolean renewLead ( UUID leaderId )  
ResultSet lwtResult = session . execute ( renewLeadPrepStmt . bind ( AppContext . REAPER_INSTANCE_ID , AppContext . REAPER_INSTANCE_ADDRESS , leaderId , AppContext . REAPER_INSTANCE_ID ) )  
if ( lwtResult . wasApplied ( ) )  
LOG . debug ( "Renewed lead on segment {}" , leaderId )  
return true  
LOG . error ( "Failed to renew lead on segment {}" , leaderId )  
return false  
@ Override public void releaseLead ( UUID leaderId )  
ResultSet lwtResult = session . execute ( releaseLeadPrepStmt . bind ( leaderId , AppContext . REAPER_INSTANCE_ID ) )  
if ( lwtResult . wasApplied ( ) )  
LOG . debug ( "Released lead on segment {}" , leaderId )  
else { assert false : "Could not release lead on segment " + leaderId  
LOG . error ( "Could not release lead on segment {}" , leaderId )  
private boolean hasLeadOnSegment ( UUID leaderId )  
ResultSet lwtResult = session . execute ( renewLeadPrepStmt . bind ( AppContext . REAPER_INSTANCE_ID , AppContext . REAPER_INSTANCE_ADDRESS , leaderId , AppContext . REAPER_INSTANCE_ID ) )  
return lwtResult . wasApplied ( )  
@ Override public void storeNodeMetrics ( NodeMetrics hostMetrics )  
session . execute ( storeNodeMetricsPrepStmt . bind ( hostMetrics . getHostAddress ( ) , hostMetrics . getDatacenter ( ) , hostMetrics . getPendingCompactions ( ) , hostMetrics . hasRepairRunning ( ) , hostMetrics . getActiveAnticompactions ( ) ) )  
@ Override public Optional < NodeMetrics > getNodeMetrics ( String hostName )  
Row metrics = session . execute ( getNodeMetricsPrepStmt . bind ( hostName ) ) . one ( )  
if ( null != metrics )  
return Optional . of ( NodeMetrics . builder ( ) . withHostAddress ( hostName ) . withDatacenter ( metrics . getString ( "datacenter" ) ) . withPendingCompactions ( metrics . getInt ( "pending_compactions" ) ) . withHasRepairRunning ( metrics . getBool ( "has_repair_running" ) ) . withActiveAnticompactions ( metrics . getInt ( "active_anticompactions" ) ) . build ( ) )  
return Optional . absent ( )  
@ Override public int countRunningReapers ( )  
ResultSet result = session . execute ( getRunningReapersCountPrepStmt . bind ( ) )  
int runningReapers = ( int ) result . one ( ) . getLong ( "nb_reapers" )  
LOG . debug ( "Running reapers = {}" , runningReapers )  
runningReapers > 0 ? runningReapers : 1  
: 1  
@ Override public void saveHeartbeat ( )  
DateTime now = DateTime . now ( )  
if ( now . minusSeconds ( 60 ) . getMillis ( ) >= lastHeartBeat . getMillis ( ) )  
session . executeAsync ( saveHeartbeatPrepStmt . bind ( AppContext . REAPER_INSTANCE_ID , AppContext . REAPER_INSTANCE_ADDRESS ) )  
lastHeartBeat = now  
private static boolean withinRange ( RepairSegment segment , Optional < RingRange > range )  
return ! range . isPresent ( ) || segmentIsWithinRange ( segment , range . get ( ) )  
private static class RetryPolicyImpl implements RetryPolicy  
@ Override public RetryDecision onReadTimeout ( Statement stmt , ConsistencyLevel cl , int required , int received , boolean retrieved , int retry )  
if ( retry > 1 )  
Thread . sleep ( 100 )  
catch ( InterruptedException ex ) {  
stmt . isIdempotent ( ) 
retry < 10 ? RetryDecision . retry ( cl ) : RetryDecision . rethrow ( ) 
retry < 10 ? RetryDecision . retry ( cl ) : RetryDecision . rethrow ( ) 
: RetryDecision . rethrow ( ) 
: DefaultRetryPolicy . INSTANCE . onReadTimeout ( stmt , cl , required , received , retrieved , retry )  
@ Override public RetryDecision onWriteTimeout ( Statement stmt , ConsistencyLevel cl , WriteType type , int required , int received , int retry )  
stmt . isIdempotent ( ) 
RetryDecision . retry ( cl ) : DefaultRetryPolicy . INSTANCE . onWriteTimeout ( stmt , cl , type , required , received , retry )  
: DefaultRetryPolicy . INSTANCE . onWriteTimeout ( stmt , cl , type , required , received , retry )  
@ Override public RetryDecision onUnavailable ( Statement stmt , ConsistencyLevel cl , int required , int aliveReplica , int retry )  
return DefaultRetryPolicy . INSTANCE . onUnavailable ( stmt , cl , required , aliveReplica , retry == 1 ? 0 : retry )  
retry == 1 ? 0 : retry )  
cl , required , aliveReplica , retry == 1 ? 0 : retry )  
@ Override public RetryDecision onRequestError ( Statement stmt , ConsistencyLevel cl , DriverException e , int nbRetry )  
return DefaultRetryPolicy . INSTANCE . onRequestError ( stmt , cl , e , nbRetry )  
@ Override public void init ( com . datastax . driver . core . Cluster cluster ) {  
@ Override public void close ( ) {  
