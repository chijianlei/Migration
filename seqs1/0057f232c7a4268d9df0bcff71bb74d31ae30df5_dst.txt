if ( iterate ( ) )  
public CCDSolver ( ArrayList < ? extends Frame > chain , Frame target )  
public boolean iterate ( )  
return true  
for ( int i = chain . size ( ) - 2 ; i >= 0 ; i -- )  
delta = new Rot ( endLocalPosition , targetLocalPosition )  
delta = new Quat ( endLocalPosition , targetLocalPosition )  
public static abstract class FABRIKSolver extends Solver  
protected ArrayList < Vec > positions = new ArrayList < Vec > ( )  
public ArrayList < Vec > getPositions ( ) { return positions ;  
public void executeForwardReaching ( ArrayList < ? extends Frame > chain )  
for ( int i = chain . size ( ) - 2 ; i >= 0 ; i -- )  
Vec pos_i = positions . get ( i )  
Vec pos_i1 = positions . get ( i + 1 )  
if ( target == null || chain . size ( ) < 2 ) return true  
: positions . get ( i + 2 )  
float dist_i = distances . get ( i + 1 )  
Vec diff = Vec . subtract ( pos_i1 , pos_i1_constrained )  
pos_i . add ( diff )  
float r_i = Vec . distance ( pos_i , pos_i1 )  
if ( dist_i == 0 )  
positions . set ( i , pos_i1 . get ( ) )  
float lambda_i = dist_i / r_i  
Vec new_pos = Vec . multiply ( pos_i1 , 1.f - lambda_i )  
new_pos . add ( Vec . multiply ( pos_i , lambda_i ) )  
positions . set ( i , new_pos )  
public float executeBackwardReaching ( ArrayList < ? extends Frame > chain )  
float change = 0  
for ( int i = 0 ; i < chain . size ( ) - 1 ; i ++ )  
float dist_i = distances . get ( i + 1 )  
if ( distances . get ( i + 1 ) == 0 )  
positions . set ( i + 1 , positions . get ( i ) )  
Vec constrained_pos = orientation . rotate ( chain . get ( i + 1 ) . translation ( ) . get ( ) )  
change += Vec . distance ( positions . get ( i + 1 ) , constrained_pos )  
positions . set ( i + 1 , constrained_pos )  
Vec newTranslation = Vec . subtract ( p , o )  
if ( parent . constraint ( ) instanceof BallAndSocket )  
if ( q == null ) return p . get ( )  
Vec newTranslation = Vec . subtract ( q , p )  
Rot desired = new Rot ( j . translation ( ) , newTranslation )  
Vec translation = orientations . get ( i ) . rotate ( j . translation ( ) . get ( ) )  
Quat reference = ( Quat ) Quat . compose ( orientations . get ( i ) , parent . rotation ( ) . inverse ( ) )  
Quat restOrientation = ( Quat ) Quat . compose ( reference , constraint . getRestRotation ( ) )  
Vec target = constraint . getConstraint ( Vec . subtract ( p , o ) , restOrientation )  
if ( parent . constraint ( ) instanceof Hinge )  
if ( parent . is2D ( ) )  
Hinge constraint = ( Hinge ) parent . constraint ( )  
constraint . constrainRotation ( desired , parent )  
Vec translation = orientations . get ( i ) . rotate ( j . translation ( ) . get ( ) )  
Vec target = constraint . getConstraint ( Vec . subtract ( p , o ) , restOrientation )  
BallAndSocket constraint = ( BallAndSocket ) parent . constraint ( )  
public float change ( ArrayList < ? extends Frame > chain )  
float change = 0.f  
for ( int i = 0 ; i < chain . size ( ) ; i ++ )  
change += Vec . distance ( chain . get ( i ) . position ( ) , positions . get ( i ) )  
public ChainSolver ( ArrayList < ? extends Frame > chain , Frame target )  
setChain ( chain )  
positions = new ArrayList < Vec > ( )  
for ( Frame joint : chain )  
Vec position = joint . position ( ) . get ( )  
this . target = target  
this . prevTarget = 
target == null ? null : new Frame ( target . position ( ) . get ( ) , target . orientation ( ) . get ( ) )  
== null ? null : new Frame ( target . position ( ) . get ( ) , target . orientation ( ) . get ( ) )  
: new Frame ( target . position ( ) . get ( ) , target . orientation ( ) . get ( ) )  
public boolean iterate ( )  
i + 2 >= chain . size ( ) ? null : positions . get ( i + 2 )  
public TreeSolver ( GenericFrame genericFrame )  
@ Override public boolean iterate ( )  
