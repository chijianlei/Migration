switch ( semanticType ) { case day : return ( s , v ) -> { s . builder . setDayOfMonth ( v ) ; } ; case facilityPriority : return ( s , v ) -> { String facilityTxt = SyslogFacility . getFacilityForCode ( v ) . toString ( ) ; String priorityTxt = SyslogSeverity . getSeverityForCode ( v ) . toString ( ) ; s . builder . setParam ( "service" , facilityTxt ) ; s . builder . setParam ( "severity" , priorityTxt ) ; s . builder . setUei ( "uei.opennms.org/syslogd/" + facilityTxt + "/" + priorityTxt ) ; } ; case hour : return ( s , v ) -> { s . builder . setHourOfDay ( v ) ; } ; case minute : return ( s , v ) -> { s . builder . setMinute ( v ) ; } ; case month : return ( s , v ) -> { s . builder . setMonth ( v ) ; } ; case processId : return ( s , v ) -> { s . builder . setParam ( "processid" , v ) ; } ; case second : return ( s , v ) -> { s . builder . setSecond ( v ) ; } ; case version : return ( s , v ) -> { s . builder . setParam ( "syslogversion" , v ) ; } ; case year : return ( s , v ) -> { s . builder . setYear ( v ) ; } ; default : 
switch ( c ) { case ' ' : switch ( patternType ) { case STRING : factory . stringUntilWhitespace ( semanticStringToEventBuilder ( semanticString ) ) ; factory . whitespace ( ) ; break ; case INTEGER : factory . intUntilWhitespace ( semanticIntegerToEventBuilder ( semanticString ) ) ; factory . whitespace ( ) ; break ; case MONTH : factory . monthString ( semanticIntegerToEventBuilder ( semanticString ) ) ; factory . whitespace ( ) ; break ; } break ; default : 
private final StringBuffer accumulatedValue  
private final AtomicInteger accumulatedSize  
public ParserStageState ( ByteBuffer input )  
buffer = input  
accumulatedValue = new StringBuffer ( )  
accumulatedSize = new AtomicInteger ( )  
public void accumulate ( char c )  
accumulatedValue . append ( c )  
accumulatedSize . incrementAndGet ( )  
public int getAccumulatedSize ( )  
return accumulatedSize . get ( )  
return new ToStringBuilder ( this ) . append ( "accumulatedValue" , accumulatedValue . toString ( ) ) . append ( "accumulatedSize" , accumulatedSize . get ( ) ) . toString ( )  
if ( m_terminal )  
return null  
return null  
protected static String getAccumulatedValue ( ParserStageState state )  
return state . accumulatedValue . toString ( )  
public class SingleSequenceParser implements ByteBufferParser < Event >  
@ Override public CompletableFuture < Event > parse ( ByteBuffer incoming )  
if ( s == null )  
return s . builder . getEvent ( )  
ByteBufferParser < Event > grokParser = new SingleSequenceParser ( grokStages )  
ByteBufferParser < Event > parser = new SingleSequenceParser ( parserStages )  
CompletableFuture < Event > event = null  
CompletableFuture < Event > event = null  
final Event [ ] events = new Event [ 4 ]  
events [ 3 ] = parseSyslog ( "syslog-ng" , syslogNgConfig , syslog )  
if ( events [ 0 ] != null || events [ 1 ] != null || events [ 2 ] != null || events [ 3 ] != null )  
results . add ( String . format ( "%s\t%s\t%s\t%s" , events [ 0 ] != null , events [ 1 ] != null , events [ 2 ] != null , events [ 3 ] != null ) )  
timestamps . add ( event . getParm ( "timestamp" ) . getValue ( ) . getContent ( ) )  
assertTrue ( "UEIs do not match" , compare ( "uei" , ueis . toArray ( new String [ 0 ] ) ) )  
assertTrue ( "times do not match" , compare ( "time" , times . toArray ( new Date [ 0 ] ) ) )  
assertTrue ( "nodeIds do not match" , compare ( "nodeId" , nodeIds . toArray ( new Long [ 0 ] ) ) )  
assertTrue ( "interfaces do not match" , compare ( "interface" , interfaces . toArray ( new String [ 0 ] ) ) )  
assertTrue ( "logmsgs do not match" , compare ( "logmsg" , logmsgs . toArray ( new String [ 0 ] ) ) )  
assertTrue ( "syslogmessage parms do not match" , compare ( "syslogmessage" , syslogmessages . toArray ( new String [ 0 ] ) ) )  
assertTrue ( "severity parms do not match" , compare ( "severity" , severities . toArray ( new String [ 0 ] ) ) )  
assertTrue ( "timestamp parms do not match" , compare ( "timestamp" , timestamps . toArray ( new String [ 0 ] ) ) )  
assertTrue ( "process parms do not match" , compare ( "process" , processes . toArray ( new String [ 0 ] ) ) )  
assertTrue ( "service parms do not match" , compare ( "service" , services . toArray ( new String [ 0 ] ) ) )  
assertTrue ( "processid parms do not match" , compare ( "processid" , processids . toArray ( new String [ 0 ] ) ) )  
assertTrue ( "parm counts do not match" , compare ( "parm count" , parmcounts . toArray ( new Long [ 0 ] ) ) )  
catch ( UnsupportedEncodingException e )  
fail ( "Unexpected exception: " + e . getMessage ( ) )  
System . out . println ( "default\tjuniper\trfc5424\tsyslog-ng" )  
private static Event parseSyslog ( final String name , final SyslogdConfig config , final String syslog ) throws UnsupportedEncodingException  
private static boolean compare ( final String value , final Long . . . strings )  
Long first = null  
for ( Long string : strings )  
LOG . warn ( "Different values for {}: {}" , value , Arrays . stream ( strings ) . map ( String : : valueOf ) . collect ( Collectors . joining ( ", " ) ) )  
return false  
if ( ! first . equals ( string ) )  
LOG . warn ( "Different values for {}: {}" , value , Arrays . stream ( strings ) . map ( String : : valueOf ) . collect ( Collectors . joining ( ", " ) ) )  
return false  
return true  
